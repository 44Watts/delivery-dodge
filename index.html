<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>3C Store Fixtures ‚Äî Lane Dodge</title>
<style>
  :root{
    --bg:#0d1326;--fg:#e8f2ff;--accent:#d64b63;--muted:#93a3b8;--good:#34d399
  }
  html,body{height:100%;margin:0;background:radial-gradient(1600px 800px at 50% -10%,#172043,var(--bg));color:var(--fg);font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{display:grid;grid-template-rows:auto 1fr auto;min-height:100%}
  header,footer{display:flex;justify-content:space-between;align-items:center;padding:10px 14px}
  header{gap:.75rem;border-bottom:1px solid rgba(255,255,255,.08)}
  footer{gap:1rem;border-top:1px solid rgba(255,255,255,.08);font-size:.95rem;color:var(--muted)}
  .pill{background:rgba(255,255,255,.08);padding:8px 10px;border-radius:999px}
  .btn{background:var(--accent);color:white;border:none;border-radius:999px;padding:10px 14px;font-weight:600;cursor:pointer}
  .btn:active{transform:translateY(1px)}
  canvas{width:min(100vw,1100px);height:auto;max-height:74vh;display:block;margin:0 auto;touch-action:none}

  /* Modal */
  .modal{position:fixed;inset:0;background:rgba(5,8,20,.65);display:none;align-items:center;justify-content:center;padding:16px;z-index:50}
  .modal.show{display:flex}
  .card{background:#0f1530;border:1px solid rgba(255,255,255,.12);border-radius:18px;box-shadow:0 18px 60px rgba(0,0,0,.45);max-width:620px;width:100%;padding:22px}
  .card h2{margin:.2rem 0 .6rem;font-size:1.35rem;color:#cfe3ff}
  .card p{color:#cbd6ea;margin:.25rem 0 .6rem;line-height:1.45}
  .row{display:flex;gap:12px;flex-wrap:wrap;margin:.2rem 0}
  .cell{flex:1 1 160px;background:rgba(255,255,255,.06);border-radius:12px;padding:10px}
  .cell b{display:block;color:#fff}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="pill">üèÅ Distance: <span id="dist">0</span> m</div>
    <div class="pill">üî• Streak: <span id="streak">0</span></div>
    <div class="pill">‚ù§Ô∏è Lives: <span id="lives">3</span></div>
    <div style="margin-left:auto;display:flex;gap:10px;align-items:center">
      <button id="help" class="btn">How to Play</button>
      <button id="restart" class="btn">Restart</button>
    </div>
  </header>

  <main>
    <canvas id="game" width="1100" height="600" aria-label="3C Truck Lane Dodge"></canvas>
  </main>

  <footer>
    <div class="pill">Controls: ‚Üë/‚Üì or W/S ‚Ä¢ Mobile: tap top/bottom ‚Ä¢ Avoid cones/barricades/cats ‚Ä¢ Grab green ¬ª¬ª speed boosts</div>
    <div>3C STORE FIXTURES ‚Äî lane dodging arcade</div>
  </footer>
</div>

<!-- Start / Help -->
<div id="startModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="startTitle">
  <div class="card">
    <h2 id="startTitle">How to Play</h2>
    <p>There are <b>3 lanes</b>. Hazards come from the <b>right</b>. Use <b>Up/Down</b> (or W/S) to switch lanes and avoid them.</p>
    <ul style="margin:.2rem 0 .6rem 1.2rem;line-height:1.5">
      <li><b>Move:</b> ‚Üë/‚Üì or W/S (desktop); tap top/bottom (mobile)</li>
      <li><b>Goal:</b> Dodge cones, barricades, and <b>cats</b></li>
      <li><b>Boost:</b> Grab green <b>¬ª¬ª</b> to gain speed & points</li>
      <li><b>Fairness:</b> Guaranteed open lane + reaction time + staggered waves</li>
    </ul>
    <div class="row" style="justify-content:flex-end">
      <button id="startBtn" class="btn">Start</button>
    </div>
  </div>
</div>

<!-- Game Over -->
<div id="overModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="overTitle">
  <div class="card">
    <h2 id="overTitle">Game Over</h2>
    <div class="row">
      <div class="cell"><b>Distance</b><span id="overDist">0 m</span></div>
      <div class="cell"><b>Best Distance</b><span id="overBest">0 m</span></div>
      <div class="cell"><b>Max Streak</b><span id="overStreak">0</span></div>
    </div>
    <div class="row" style="justify-content:flex-end">
      <button id="again" class="btn">Play Again</button>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const c = canvas.getContext('2d');

  // UI
  const distEl = document.getElementById('dist');
  const streakEl = document.getElementById('streak');
  const livesEl = document.getElementById('lives');
  const restartBtn = document.getElementById('restart');
  const helpBtn = document.getElementById('help');

  // Modals
  const startModal = document.getElementById('startModal');
  const overModal = document.getElementById('overModal');
  const startBtn = document.getElementById('startBtn');
  const againBtn = document.getElementById('again');
  const overDist = document.getElementById('overDist');
  const overBest = document.getElementById('overBest');
  const overStreak = document.getElementById('overStreak');

  // ======= WORLD / TUNING =======
  const W = canvas.width, H = canvas.height;
  const roadTop = 100;
  const roadBottom = H - 70;
  const lanes = 3;

  // Speed curve (gentler)
  const BASE_SPEED = 220;
  const MAX_SPEED  = 360;  // lower top speed
  const SPEED_GAIN = 2.6;  // slower acceleration

  // Truck geometry (SLIM) + forgiving hitbox
  const TRUCK = { w: 170, h: 60 };
  const TRUCK_X = 150;
  const HITBOX_PAD = 24;

  // Lane-change responsiveness (set to 99999 for instant snap)
  const LANE_CHANGE_SPEED = 1800; // px/s

  // Obstacles & pickups
  const OBST = { w: 48, h: 48 }; // slimmer for more gaps
  const PICK = { w: 58, h: 42 };

  // Spawning safety rules
  const DESIRED_GAP_PX = 300; // per-lane spacing
  const BOOST_CHANCE   = 0.20;
  const REACTION_TIME_S = 0.80; // must have at least this much time to react
  const EXTRA_BUFFER_PX = 180;  // fudge factor beyond physics
  const STAGGER_PX      = 100;  // offset within multi-lane waves
  const WINDOW_AHEAD_PX = 260;  // "danger window" ahead of truck to avoid walls

  // Lane centers
  const laneYs = [];
  for (let i=0;i<lanes;i++){
    const t = (i + 0.5) / lanes;
    laneYs.push(roadTop + t * (roadBottom - roadTop));
  }

  // Game state
  let running = false, paused = false, over = false;
  let distance = 0, bestDistance = 0, speed = BASE_SPEED;
  let streak = 0, maxStreak = 0;
  let lives = 3;
  let last = performance.now();

  // Objects & effects
  const objs = [];
  const floatTexts = [];
  let spawnTimer = 0;
  const laneCooldown = Array(lanes).fill(0); // seconds remaining per lane
  let truckGlow = 0;

  // Truck state
  let truck = { y: laneYs[1] - TRUCK.h/2, targetLane: 1 };

  function resetGame(){
    distance = 0; streak = 0; maxStreak = 0; speed = BASE_SPEED; lives = 3;
    objs.length = 0; floatTexts.length = 0; laneCooldown.fill(0);
    truck.targetLane = 1; truck.y = laneYs[1] - TRUCK.h/2;
    over = false; running = true; paused = false; truckGlow = 0;
    updateHUD();
  }

  function updateHUD(){
    distEl.textContent = Math.floor(distance).toString();
    streakEl.textContent = streak.toString();
    livesEl.textContent = lives.toString();
  }

  function showStart(){ startModal.classList.add('show'); }
  function hideStart(){ startModal.classList.remove('show'); }
  function showOver(){ overModal.classList.add('show'); }
  function hideOver(){ overModal.classList.remove('show'); }

  // Helpers
  function roundRect(ctx, x, y, w, h, r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  function shuffle(arr){
    for (let i = arr.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function laneBlockedInWindow(lane, xStart, xEnd){
    return objs.some(o =>
      o.kind === 'obst' &&
      o.lane === lane &&
      (o.x < xEnd) && (o.x + o.w > xStart)
    );
  }

  function safeSpawnX(vxAbs){
    // time to reach truck = (x - TRUCK_X) / vxAbs  >= REACTION_TIME_S
    const minX = TRUCK_X + vxAbs * REACTION_TIME_S + EXTRA_BUFFER_PX;
    return Math.max(W + 30, minX);
  }

  function drawBackground(){
    // Sky
    const sky = c.createLinearGradient(0,0,0,H);
    sky.addColorStop(0,'#7ec8ff'); sky.addColorStop(.6,'#bfe3ff'); sky.addColorStop(1,'#eaf6ff');
    c.fillStyle = sky; c.fillRect(0,0,W,H);

    // Clouds
    c.fillStyle = 'rgba(255,255,255,.9)';
    const cloud=(x,y,s)=>{c.beginPath();c.ellipse(x,y,50*s,30*s,0,0,Math.PI*2);
      c.ellipse(x+40*s,y+5*s,40*s,25*s,0,0,Math.PI*2);
      c.ellipse(x-40*s,y+10*s,40*s,25*s,0,0,Math.PI*2); c.fill();};
    cloud(180,70,1.0); cloud(420,60,1.15); cloud(860,96,1.1);

    // Road
    c.fillStyle = '#505563'; c.fillRect(0, roadTop, W, roadBottom-roadTop);

    // Lane separators
    c.strokeStyle = 'rgba(255,255,255,.8)';
    c.setLineDash([28,18]); c.lineWidth = 4;
    for (let i=1;i<lanes;i++){
      const y = roadTop + (i/lanes)*(roadBottom-roadTop);
      c.beginPath(); c.moveTo(0, y); c.lineTo(W, y); c.stroke();
    }
    c.setLineDash([]);

    // Shoulders
    c.fillStyle = '#2f3440'; c.fillRect(0, roadTop-8, W, 8);
    c.fillRect(0, roadBottom, W, 8);
  }

  // 10-wheeler cargo truck (right-facing) ‚Äî SLIM drawing
  function drawTruck10(x, yTop, withGlow=false){
    const y = yTop;

    if (withGlow){
      c.save();
      c.globalCompositeOperation = 'lighter';
      c.shadowColor = '#00ff88';
      c.shadowBlur = 22;
      roundRect(c, x-120, y-6, 200, TRUCK.h+12, 16);
      c.fillStyle = 'rgba(0,255,140,0.22)';
      c.fill(); c.restore();
    }

    // Trailer (shorter)
    c.save();
    roundRect(c, x-100, y+4, 120, TRUCK.h-8, 10);
    c.fillStyle = '#f7f8fb'; c.fill(); c.lineWidth = 2.5; c.strokeStyle = '#bcc7d6'; c.stroke();

    // Branding
    c.fillStyle = '#6d7a8c'; c.font = 'bold 13px Inter, Arial';
    c.fillText('3C STORE',  x-94, y+24);
    c.fillText('FIXTURES',  x-94, y+40);
    c.fillStyle = '#d64b63'; c.fillRect(x+12, y+6, 18, 18);
    c.fillStyle = '#fff'; c.font = 'bold 12px Inter, Arial'; c.fillText('3C', x+15, y+20);

    // Cab (narrower)
    roundRect(c, x, y, 90, TRUCK.h, 12); c.fillStyle='#ffffff'; c.fill(); c.strokeStyle='#bcc7d6'; c.lineWidth=2.5; c.stroke();

    // Grill / bumper / headlight
    c.fillStyle = '#cfd6e0'; c.fillRect(x+78, y+12, 10, 20);
    c.fillStyle = '#9aa7ba'; c.fillRect(x+84, y+15, 6, 14);
    c.fillStyle = '#ffd27d'; c.fillRect(x+88, y+36, 8, 10);

    // Windshield
    c.fillStyle='#1b2635'; c.beginPath();
    c.moveTo(x+16, y+14); c.lineTo(x+76, y+14); c.lineTo(x+76, y+40); c.lineTo(x+38, y+40); c.closePath(); c.fill();

    // Door & handle
    c.fillStyle='#e9eef6'; c.fillRect(x+56, y+46, 26, 30);
    c.fillStyle='#8a95a6'; c.fillRect(x+72, y+58, 6, 6);

    // Accent stripe
    c.fillStyle = '#d64b63'; c.fillRect(x, y+52, 72, 12);

    // 5 axles (10 wheels)
    function dual(wx, wy){
      c.beginPath(); c.arc(wx-6, wy, 10, 0, Math.PI*2); c.fillStyle='#1c2230'; c.fill();
      c.beginPath(); c.arc(wx-6, wy, 5, 0, Math.PI*2); c.fillStyle='#c4ccd8'; c.fill();
      c.beginPath(); c.arc(wx+6, wy, 10, 0, Math.PI*2); c.fillStyle='#1c2230'; c.fill();
      c.beginPath(); c.arc(wx+6, wy, 5, 0, Math.PI*2); c.fillStyle='#c4ccd8'; c.fill();
    }
    const wy = y + TRUCK.h - 4;
    dual(x+22,  wy);  // steer
    dual(x+52,  wy);  // drive 1
    dual(x+82,  wy);  // drive 2
    dual(x-34,  wy);  // trailer 1
    dual(x-62,  wy);  // trailer 2
    c.restore();
  }

  function drawObstacle(o){
    c.save(); c.translate(o.x, o.y);
    if (o.kind === 'pick'){ // green chevrons >>
      const w=PICK.w, h=PICK.h;
      c.fillStyle = '#16a34a';
      c.beginPath(); c.moveTo(8, h*0.2);  c.lineTo(w*0.45, h*0.5); c.lineTo(8, h*0.8); c.closePath(); c.fill();
      c.beginPath(); c.moveTo(w*0.35, h*0.2);  c.lineTo(w-8, h*0.5); c.lineTo(w*0.35, h*0.8); c.closePath(); c.fill();
      c.strokeStyle='#064e3b'; c.lineWidth=2; c.strokeRect(4, 6, w-8, h-12);
    } else {
      if (o.type === 'cone'){
        c.fillStyle = '#ff7a00';
        c.beginPath(); c.moveTo(0,OBST.h); c.lineTo(OBST.w*0.5,0); c.lineTo(OBST.w,OBST.h); c.closePath(); c.fill();
        c.fillStyle='#fff'; c.fillRect(OBST.w*0.2, OBST.h*0.55, OBST.w*0.6, 6);
        c.fillRect(OBST.w*0.25, OBST.h*0.76, OBST.w*0.5, 6);
      } else if (o.type === 'barricade'){
        roundRect(c, 0, 8, OBST.w, OBST.h-12, 8); c.fillStyle='#222830'; c.fill();
        for(let i=0;i<6;i++){ c.fillStyle = (i%2 ? '#ff6b6b' : '#ffd166'); c.fillRect(6+i*9, 12, 8, OBST.h-24); }
      } else if (o.type === 'cat'){
        const w=OBST.w, h=OBST.h;
        c.fillStyle = '#2b2b2b';
        roundRect(c, 8, h*0.35, w-16, h*0.5, 10); c.fill();               // body
        c.beginPath(); c.arc(18, h*0.35, 12, 0, Math.PI*2); c.fill();      // head
        // ears
        c.beginPath(); c.moveTo(10, h*0.2); c.lineTo(14, h*0.1); c.lineTo(18, h*0.22); c.closePath(); c.fill();
        c.beginPath(); c.moveTo(22, h*0.2); c.lineTo(26, h*0.1); c.lineTo(30, h*0.22); c.closePath(); c.fill();
        // tail
        c.beginPath(); c.moveTo(w-10, h*0.55); c.quadraticCurveTo(w, h*0.3, w-6, h*0.25); c.lineWidth=6; c.strokeStyle='#2b2b2b'; c.stroke();
        // eye
        c.fillStyle='#f6f6f6'; c.beginPath(); c.arc(22, h*0.34, 1.6, 0, Math.PI*2); c.fill();
      }
    }
    c.restore();
  }

  // -------- Guaranteed-gap spawning with reaction-time & stagger --------
  function spawnInLane(lane){
    const yCenter = laneYs[lane];
    const isBoost = Math.random() < BOOST_CHANCE;

    if (isBoost){
      const vxPick = speed * (Math.random()*0.15 + 0.95);
      objs.push({
        kind: 'pick',
        type: 'boost',
        lane,
        x: safeSpawnX(vxPick),
        y: yCenter - PICK.h/2,
        w: PICK.w, h: PICK.h,
        vx: -vxPick,
        passed: false
      });
    } else {
      const roll = Math.random();
      const type = roll < 0.33 ? 'barricade' : (roll < 0.66 ? 'cat' : 'cone');
      const vxObst = speed * (Math.random()*0.2 + 0.9);
      objs.push({
        kind: 'obst',
        type,
        lane,
        x: safeSpawnX(vxObst),
        y: yCenter - OBST.h/2,
        w: OBST.w, h: OBST.h,
        vx: -vxObst,
        passed: false
      });
    }

    // lane cooldown from pixel gap
    const pxPerSec = Math.max(160, speed);
    laneCooldown[lane] = DESIRED_GAP_PX / pxPerSec; // seconds
  }

  function spawnTick(dt){
    // tick down lane cooldowns
    for (let i=0;i<lanes;i++) laneCooldown[i] = Math.max(0, laneCooldown[i] - dt);

    // global cadence scales with speed
    const baseInterval = Math.max(0.65, 1.25 - speed/700);
    spawnTimer -= dt;

    if (spawnTimer <= 0){
      const open = [];
      for (let i=0;i<lanes;i++) if (laneCooldown[i] <= 0) open.push(i);

      if (open.length > 0){
        // spawn in 1 or 2 lanes (never all 3); bias to 1
        let count = Math.random() < 0.65 ? 1 : 2;
        count = Math.min(count, open.length, lanes - 1);

        // avoid "wall" in window ahead of truck
        const xWindowStart = TRUCK_X + 40;
        const xWindowEnd   = TRUCK_X + WINDOW_AHEAD_PX;

        shuffle(open);
        const chosen = [];
        for (const lane of open){
          if (chosen.length >= count) break;

          const tentative = [...chosen, lane];
          let blocked = 0;
          for (let L=0; L<lanes; L++){
            const willSpawnHere = tentative.includes(L);
            const alreadyBlocked = laneBlockedInWindow(L, xWindowStart, xWindowEnd);
            if (willSpawnHere || alreadyBlocked) blocked++;
          }
          if (blocked <= 2) chosen.push(lane); // only if at least 1 lane remains open
        }

        // spawn and stagger
        chosen.forEach((lane, idx) => {
          spawnInLane(lane);
          const obj = objs[objs.length-1];
          obj.x += idx * STAGGER_PX;
        });
      }

      // schedule next attempt
      spawnTimer = baseInterval * (0.9 + Math.random() * 0.3);
    }
  }
  // ---------------------------------------------------------------------

  function rectOverlap(ax,ay,aw,ah, bx,by,bw,bh){
    return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
  }

  // Effects
  let shakeTime=0, flashTime=0;
  function shake(ms){ shakeTime = ms; }
  function flash(ms){ flashTime = ms; }

  function update(dt){
    if (!running || paused || over) return;

    // Speed curve
    speed += SPEED_GAIN*dt; if (speed > MAX_SPEED) speed = MAX_SPEED;

    // Score
    distance += speed * dt * 0.25;
    updateHUD();

    // Spawning
    spawnTick(dt);

    // Move objects & resolve
    for (let i=objs.length-1;i>=0;i--){
      const o = objs[i];
      o.x += o.vx * dt;

      if (!o.passed && o.x + o.w < TRUCK_X){
        o.passed = true;
        if (o.kind === 'obst'){ streak++; if (streak>maxStreak) maxStreak=streak; }
      }

      // Forgiving truck hitbox
      const tx = TRUCK_X + HITBOX_PAD, ty = truck.y + HITBOX_PAD;
      const tw = TRUCK.w - HITBOX_PAD*2, th = TRUCK.h - HITBOX_PAD*2;

      if (rectOverlap(tx,ty,tw,th, o.x,o.y,o.w,o.h)){
        if (o.kind === 'pick'){
          // BOOST: speed bump + points + glow + floating text
          objs.splice(i,1);
          distance += 12;
          speed = Math.min(speed + 60, MAX_SPEED);
          truckGlow = 260;
          floatTexts.push({text:"+Speed!", x: TRUCK_X + TRUCK.w/2, y: truck.y - 6, life: 900});
          continue;
        } else {
          // OBSTACLE collision
          objs.splice(i,1);
          lives--; streak = 0;
          shake(140); flash(110);
          if (lives <= 0){
            running = false; over = true;
            bestDistance = Math.max(bestDistance, Math.floor(distance));
            overDist.textContent = Math.floor(distance)+' m';
            overBest.textContent = bestDistance+' m';
            overStreak.textContent = maxStreak.toString();
            setTimeout(()=>showOver(), 220);
          }
          updateHUD();
          continue;
        }
      }

      // Cleanup
      if (o.x < -200) objs.splice(i,1);
    }

    // Lane change (fast glide; set LANE_CHANGE_SPEED=99999 for snap)
    const targetY = laneYs[truck.targetLane] - TRUCK.h/2;
    const dy = targetY - truck.y;
    truck.y += Math.sign(dy) * Math.min(Math.abs(dy), LANE_CHANGE_SPEED * dt);

    // Floating texts
    for (let i=floatTexts.length-1;i>=0;i--){
      const t = floatTexts[i];
      t.y -= 40 * dt;
      t.life -= dt*1000;
      if (t.life <= 0) floatTexts.splice(i,1);
    }

    // Truck glow timer
    if (truckGlow > 0) truckGlow -= dt*1000;
  }

  function render(){
    const now = performance.now();
    const dt = Math.min(0.05, (now - last)/1000);
    last = now;

    update(dt);

    // Shake offset
    let sx=0, sy=0;
    if (shakeTime>0){
      shakeTime -= dt*1000;
      const p = Math.max(0, shakeTime/1000);
      sx = (Math.random()-.5)*9*p; sy = (Math.random()-.5)*9*p;
    }

    c.save(); c.translate(sx, sy);
    drawBackground();

    // Draw objects
    for (const o of objs) drawObstacle(o);

    // Draw truck
    drawTruck10(TRUCK_X, truck.y, truckGlow > 0);

    // Floating texts
    c.save();
    c.font = "bold 24px Inter, Arial";
    c.textAlign = "center";
    for (const t of floatTexts){
      const alpha = Math.max(0, Math.min(1, t.life / 900));
      c.fillStyle = `rgba(50,205,50,${alpha})`;
      c.fillText(t.text, t.x, t.y);
    }
    c.restore();

    c.restore();

    // Damage flash overlay
    if (flashTime>0){
      flashTime -= dt*1000;
      c.fillStyle = '#5a0f0f';
      c.globalAlpha = Math.max(0, flashTime/180);
      c.fillRect(0,0,W,H);
      c.globalAlpha = 1;
    }

    requestAnimationFrame(render);
  }

  // Input
  function moveLane(delta){
    if (!running || over) return;
    truck.targetLane = Math.max(0, Math.min(lanes-1, (truck.targetLane ?? 1) + delta));
  }

  window.addEventListener('keydown', (e)=>{
    if (e.code==='ArrowUp' || e.code==='KeyW'){ e.preventDefault(); moveLane(-1); }
    if (e.code==='ArrowDown'|| e.code==='KeyS'){ e.preventDefault(); moveLane( 1); }
    if (e.code==='KeyP'){ paused = !paused; }
    if (e.code==='Enter' && over){ hideOver(); resetGame(); }
  });

  // Touch: tap top/bottom halves to change lanes
  canvas.addEventListener('pointerdown', (e)=>{
    const rect = canvas.getBoundingClientRect();
    const y = (e.clientY - rect.top) * (H / rect.height);
    if (y < (roadTop + roadBottom)/2) moveLane(-1); else moveLane(1);
  });

  // Buttons & modals
  restartBtn.addEventListener('click', ()=>{ hideOver(); resetGame(); });
  helpBtn.addEventListener('click', ()=>{ running=false; paused=true; showStart(); });
  startBtn.addEventListener('click', ()=>{ hideStart(); paused=false; running=true; });
  againBtn.addEventListener('click', ()=>{ hideOver(); resetGame(); });

  // Boot
  showStart();
  render();
})();
</script>
</body>
</html>
