<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>3C Store Fixtures - Delivery Dodge</title>
<style>
  :root{
    --bg:#0d1326;--fg:#e8f2ff;--accent:#d64b63;--muted:#93a3b8;--good:#34d399
  }
  html,body{height:100%;margin:0;background:radial-gradient(1600px 800px at 50% -10%,#172043,var(--bg));color:var(--fg);font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{display:grid;grid-template-rows:auto 1fr auto;min-height:100%}
  header,footer{display:flex;justify-content:space-between;align-items:center;padding:10px 14px}
  header{gap:.75rem;border-bottom:1px solid rgba(255,255,255,.08)}
  footer{gap:1rem;border-top:1px solid rgba(255,255,255,.08);font-size:.95rem;color:var(--muted)}
  .pill{background:rgba(255,255,255,.08);padding:8px 10px;border-radius:999px}
  .btn{background:var(--accent);color:white;border:none;border-radius:999px;padding:10px 14px;font-weight:600;cursor:pointer}
  .btn:active{transform:translateY(1px)}
  canvas{width:min(100vw,1100px);height:auto;max-height:74vh;display:block;margin:0 auto;touch-action:none}

  .modal{position:fixed;inset:0;background:rgba(5,8,20,.65);display:none;align-items:center;justify-content:center;padding:16px;z-index:50}
  .modal.show{display:flex}
  .card{background:#0f1530;border:1px solid rgba(255,255,255,.12);border-radius:18px;box-shadow:0 18px 60px rgba(0,0,0,.45);max-width:620px;width:100%;padding:22px}
  .card h2{margin:.2rem 0 .6rem;font-size:1.35rem;color:#cfe3ff}
  .card p{color:#cbd6ea;margin:.25rem 0 .6rem;line-height:1.45}
  .row{display:flex;gap:12px;flex-wrap:wrap;margin:.2rem 0}
  .cell{flex:1 1 160px;background:rgba(255,255,255,.06);border-radius:12px;padding:10px}
  .cell b{display:block;color:#fff}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="pill">üèÅ Distance: <span id="dist">0</span> m</div>
    <div class="pill">üî• Streak: <span id="streak">0</span></div>
    <div class="pill">‚ù§Ô∏è Lives: <span id="lives">3</span></div>
    <div style="margin-left:auto;display:flex;gap:10px;align-items:center">
      <button id="help" class="btn">How to Play</button>
      <button id="restart" class="btn">Restart</button>
    </div>
  </header>

  <main>
    <canvas id="game" width="1100" height="600" aria-label="3C Truck Lane Dodge"></canvas>
  </main>

  <footer>
    <div class="pill">Controls: ‚Üë/‚Üì or W/S ‚Ä¢ Mobile: tap top/bottom ‚Ä¢ Avoid cones/barricades/cats ‚Ä¢ Grab green ¬ª¬ª boosts</div>
    <div>3C STORE FIXTURES ‚Äî lane dodging arcade</div>
  </footer>
</div>

<!-- Start / Help -->
<div id="startModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="startTitle">
  <div class="card">
    <h2 id="startTitle">How to Play</h2>
    <p>There are <b>3 lanes</b>. Obstacles come from the right. Use <b>Up/Down</b> (or W/S) to switch lanes and avoid them. Boosts give points & a little speed.</p>
    <ul style="margin:.2rem 0 .6rem 1.2rem;line-height:1.5">
      <li><b>Fairness:</b> One obstacle per wave + always a safe lane + reaction-safe spawns</li>
      <li><b>Grace:</b> 180ms invulnerability right after you switch lanes</li>
      <li><b>Goal:</b> Go far without losing all 3 lives</li>
    </ul>
    <div class="row" style="justify-content:flex-end">
      <button id="startBtn" class="btn">Start</button>
    </div>
  </div>
</div>

<!-- Game Over -->
<div id="overModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="overTitle">
  <div class="card">
    <h2 id="overTitle">Game Over</h2>
    <div class="row">
      <div class="cell"><b>Distance</b><span id="overDist">0 m</span></div>
      <div class="cell"><b>Best Distance</b><span id="overBest">0 m</span></div>
      <div class="cell"><b>Max Streak</b><span id="overStreak">0</span></div>
    </div>
    <div class="row" style="justify-content:flex-end">
      <button id="again" class="btn">Play Again</button>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const c = canvas.getContext('2d');

  // === Load the TRUCK IMAGE (1112x358) ===
  const truckImg = new Image();
  truckImg.src = 'truck.png'; // must be in the same folder as this HTML
  let truckImgReady = false;
  truckImg.onload = () => truckImgReady = true;

  // UI
  const distEl = document.getElementById('dist');
  const streakEl = document.getElementById('streak');
  const livesEl = document.getElementById('lives');
  const restartBtn = document.getElementById('restart');
  const helpBtn = document.getElementById('help');

  // Modals
  const startModal = document.getElementById('startModal');
  const overModal = document.getElementById('overModal');
  const startBtn = document.getElementById('startBtn');
  const againBtn = document.getElementById('again');
  const overDist = document.getElementById('overDist');
  const overBest = document.getElementById('overBest');
  const overStreak = document.getElementById('overStreak');

  // ======= TUNING =======
  const W = canvas.width, H = canvas.height;
  const roadTop = 80;
  const roadBottom = H - 60;
  const lanes = 3;

  // Gentler speed = more time to react
  const BASE_SPEED = 180;
  const MAX_SPEED  = 280;
  const SPEED_GAIN = 1.8;

  // Truck (size) + forgiving hitbox
  const TRUCK = { w: 140, h: 50 };
  const TRUCK_X = 140;
  const HITBOX_PAD = 30;

  // Fast glide lane change (keeps your preferred feel)
  const LANE_CHANGE_SPEED = 1800; // px/s

  // Obstacles & boosts (smaller)
  const OBST = { w: 32, h: 30 };
  const PICK = { w: 44, h: 28 };

  // Spawning / fairness
  const DESIRED_GAP_PX = 500;  // bigger same-lane spacing
  const BOOST_CHANCE   = 0.18; // fewer boosts, mostly obstacles
  const REACTION_TIME_S = 0.95; // base reaction time
  const EXTRA_BUFFER_PX = 240;  // extra cushion
  const WINDOW_AHEAD_PX = 320;  // min clear window
  const GAP_FACTOR      = 1.5;  // keep ‚â• 1.5√ó truck width clear
  const STAGGER_PX      = 140;  // (we spawn 1 lane per wave, but keep for safety)

  // Global limits (prevents clutter)
  const MAX_OBJS_ON_SCREEN = 7;    // total (obstacles + boosts)
  const MAX_OBST_PER_LANE  = 3;    // avoid lane spam

  // Lane centers
  const laneYs = [];
  for (let i=0;i<lanes;i++){
    const t = (i + 0.5) / lanes;
    laneYs.push(roadTop + t * (roadBottom - roadTop));
  }

  // Game state
  let running = false, paused = false, over = false;
  let distance = 0, bestDistance = 0, speed = BASE_SPEED;
  let streak = 0, maxStreak = 0;
  let lives = 3;
  let last = performance.now();

  // Objects & effects
  const objs = [];
  const floatTexts = [];
  let spawnTimer = 0;
  const laneCooldown = Array(lanes).fill(0); // seconds remaining per lane
  let truckGlow = 0;

  // Short grace after lane change
  const INVULN_MS = 180;
  let invulnMs = 0;

  // Truck state
  let truck = { y: laneYs[1] - TRUCK.h/2, targetLane: 1 };

  function resetGame(){
    distance = 0; streak = 0; maxStreak = 0; speed = BASE_SPEED; lives = 3;
    objs.length = 0; floatTexts.length = 0; laneCooldown.fill(0);
    truck.targetLane = 1; truck.y = laneYs[1] - TRUCK.h/2;
    over = false; running = true; paused = false; truckGlow = 0; invulnMs = 0;
    updateHUD();
  }

  function updateHUD(){
    distEl.textContent = Math.floor(distance).toString();
    streakEl.textContent = streak.toString();
    livesEl.textContent = lives.toString();
  }

  function showStart(){ startModal.classList.add('show'); }
  function hideStart(){ startModal.classList.remove('show'); }
  function showOver(){ overModal.classList.add('show'); }
  function hideOver(){ overModal.classList.remove('show'); }

  // Helpers
  function roundRect(ctx, x, y, w, h, r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }
  function shuffle(arr){
    for (let i = arr.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  // Interval helpers for fairness window
  function laneIntervalsInWindow(lane, xStart, xEnd){
    const segs = [];
    for (const o of objs){
      if (o.kind !== 'obst' || o.lane !== lane) continue;
      const a = o.x, b = o.x + o.w;
      if (b <= xStart || a >= xEnd) continue;
      segs.push([Math.max(a,xStart), Math.min(b,xEnd)]);
    }
    segs.sort((p,q)=>p[0]-q[0]);
    const merged = [];
    for (const s of segs){
      if (!merged.length || s[0] > merged[merged.length-1][1] + 0.001){
        merged.push([s[0], s[1]]);
      } else {
        merged[merged.length-1][1] = Math.max(merged[merged.length-1][1], s[1]);
      }
    }
    return merged;
  }
  function laneHasGapLen(lane, xStart, gapLen){
    const xEnd = xStart + gapLen;
    const blocks = laneIntervalsInWindow(lane, xStart, xEnd);
    let cursor = xStart;
    for (const [a,b] of blocks){
      if (a > cursor) return true;
      cursor = Math.max(cursor, b);
    }
    return cursor < xEnd;
  }
  function laneBlockedInWindow(lane, xStart, xEnd){
    return laneIntervalsInWindow(lane, xStart, xEnd).length > 0;
  }
  function timeToReachLane(targetLaneIndex){
    const targetY = laneYs[targetLaneIndex] - TRUCK.h/2;
    const dy = Math.abs(targetY - truck.y);
    return dy / Math.max(1, LANE_CHANGE_SPEED); // seconds
  }
  function safeSpawnX(vxAbs, requiredReactS){
    const minX = TRUCK_X + vxAbs * requiredReactS + EXTRA_BUFFER_PX;
    return Math.max(W + 30, minX);
  }

  function drawBackground(){
    // Sky
    const sky = c.createLinearGradient(0,0,0,H);
    sky.addColorStop(0,'#7ec8ff'); sky.addColorStop(.6,'#bfe3ff'); sky.addColorStop(1,'#eaf6ff');
    c.fillStyle = sky; c.fillRect(0,0,W,H);

    // Clouds
    c.fillStyle = 'rgba(255,255,255,.9)';
    const cloud=(x,y,s)=>{c.beginPath();c.ellipse(x,y,50*s,30*s,0,0,Math.PI*2);
      c.ellipse(x+40*s,y+5*s,40*s,25*s,0,0,Math.PI*2);
      c.ellipse(x-40*s,y+10*s,40*s,25*s,0,0,Math.PI*2); c.fill();};
    cloud(180,70,1.0); cloud(420,60,1.15); cloud(860,96,1.1);

    // Road
    c.fillStyle = '#505563'; c.fillRect(0, roadTop, W, roadBottom-roadTop);

    // Lane separators
    c.strokeStyle = 'rgba(255,255,255,.8)';
    c.setLineDash([28,18]); c.lineWidth = 4;
    for (let i=1;i<lanes;i++){
      const y = roadTop + (i/lanes)*(roadBottom-roadTop);
      c.beginPath(); c.moveTo(0, y); c.lineTo(W, y); c.stroke();
    }
    c.setLineDash([]);

    // Shoulders
    c.fillStyle = '#2f3440'; c.fillRect(0, roadTop-8, W, 8);
    c.fillRect(0, roadBottom, W, 8);
  }

  // === NEW: Draw truck using the loaded PNG ===
  function drawTruckImage(x, y, withGlow=false){
    if (withGlow){
      c.save();
      c.globalCompositeOperation = 'lighter';
      c.shadowColor = '#00ff88';
      c.shadowBlur = 18;
      roundRect(c, x - 12, y - 6, TRUCK.w + 24, TRUCK.h + 12, 14);
      c.fillStyle = 'rgba(0,255,140,0.22)';
      c.fill(); 
      c.restore();
    }
    if (truckImgReady){
      // Draw scaled to TRUCK.w √ó TRUCK.h (keeps all your tuning consistent)
      c.drawImage(truckImg, x, y, TRUCK.w, TRUCK.h);
    } else {
      // Fallback placeholder while loading
      c.fillStyle = '#fff';
      c.fillRect(x, y, TRUCK.w, TRUCK.h);
      c.strokeStyle = '#8893a6';
      c.strokeRect(x, y, TRUCK.w, TRUCK.h);
    }
  }

  function drawObstacle(o){
    c.save(); c.translate(o.x, o.y);
    if (o.kind === 'pick'){ // green chevrons >>
      const w=PICK.w, h=PICK.h;
      c.fillStyle = '#16a34a';
      c.beginPath(); c.moveTo(8, h*0.2);  c.lineTo(w*0.45, h*0.5); c.lineTo(8, h*0.8); c.closePath(); c.fill();
      c.beginPath(); c.moveTo(w*0.35, h*0.2);  c.lineTo(w-8, h*0.5); c.lineTo(w*0.35, h*0.8); c.closePath(); c.fill();
      c.strokeStyle='#064e3b'; c.lineWidth=2; c.strokeRect(4, 6, w-8, h-12);
    } else {
      if (o.type === 'cone'){
        c.fillStyle = '#ff7a00';
        c.beginPath(); c.moveTo(0,OBST.h); c.lineTo(OBST.w*0.5,0); c.lineTo(OBST.w,OBST.h); c.closePath(); c.fill();
        c.fillStyle='#fff'; c.fillRect(OBST.w*0.18, OBST.h*0.55, OBST.w*0.64, 5);
        c.fillRect(OBST.w*0.25, OBST.h*0.76, OBST.w*0.5, 5);
      } else if (o.type === 'barricade'){
        roundRect(c, 0, 8, OBST.w, OBST.h-12, 8); c.fillStyle='#222830'; c.fill();
        for(let i=0;i<5;i++){ c.fillStyle = (i%2 ? '#ff6b6b' : '#ffd166'); c.fillRect(5+i*7, 12, 6, OBST.h-24); }
      } else if (o.type === 'cat'){
        const w=OBST.w, h=OBST.h;
        c.fillStyle = '#2b2b2b';
        roundRect(c, 6, h*0.35, w-12, h*0.5, 8); c.fill();               // body
        c.beginPath(); c.arc(16, h*0.35, 10, 0, Math.PI*2); c.fill();     // head
        // ears
        c.beginPath(); c.moveTo(9, h*0.2); c.lineTo(12, h*0.1); c.lineTo(16, h*0.22); c.closePath(); c.fill();
        c.beginPath(); c.moveTo(20, h*0.2); c.lineTo(23, h*0.1); c.lineTo(27, h*0.22); c.closePath(); c.fill();
        // tail
        c.beginPath(); c.moveTo(w-8, h*0.55); c.quadraticCurveTo(w, h*0.3, w-5, h*0.25); c.lineWidth=5; c.strokeStyle='#2b2b2b'; c.stroke();
        // eye
        c.fillStyle='#f6f6f6'; c.beginPath(); c.arc(20, h*0.34, 1.3, 0, Math.PI*2); c.fill();
      }
    }
    c.restore();
  }

  // -------- Spawning: ALWAYS fair, 1 lane per wave, guaranteed gap ----------
  function spawnTick(dt){
    // tick cooldowns
    for (let i=0;i<lanes;i++) laneCooldown[i] = Math.max(0, laneCooldown[i] - dt);

    // global cadence
    const baseInterval = Math.max(0.7, 1.35 - speed/700);
    spawnTimer -= dt;

    if (spawnTimer > 0) return;

    // Avoid clutter: cap total objects
    if (objs.length >= MAX_OBJS_ON_SCREEN) {
      spawnTimer = baseInterval * 0.8;
      return;
    }

    // Open lanes (not on cooldown)
    const open = [];
    for (let i=0;i<lanes;i++) if (laneCooldown[i] <= 0) open.push(i);
    if (open.length === 0){
      spawnTimer = baseInterval * 0.9;
      return;
    }

    // Count obstacles per lane to avoid lane spam
    const laneCounts = Array(lanes).fill(0);
    for (const o of objs) if (o.kind==='obst') laneCounts[o.lane]++;

    // Determine ‚Äúsafe gap‚Äù lanes ahead
    const xWindowStart = TRUCK_X + 40;
    const requiredGap = Math.max(GAP_FACTOR * TRUCK.w, WINDOW_AHEAD_PX);
    const gapLanes = [];
    for (let i=0;i<lanes;i++){
      if (laneCounts[i] < MAX_OBST_PER_LANE &&
          laneHasGapLen(i, xWindowStart, requiredGap)) gapLanes.push(i);
    }

    // If no lane has a proper gap, skip this wave to preserve fairness
    if (gapLanes.length === 0){
      spawnTimer = baseInterval * 0.8;
      return;
    }

    // Choose the EASIEST gap lane to reach (shortest glide time)
    let bestLane = gapLanes[0], bestTime = Infinity;
    for (const L of gapLanes){
      const t = timeToReachLane(L);
      if (t < bestTime){ bestTime = t; bestLane = L; }
    }

    // We only spawn in ONE other lane (never all 3 ‚Üí never walls)
    const spawnable = open.filter(l => l !== bestLane && laneCounts[l] < MAX_OBST_PER_LANE);
    if (spawnable.length === 0){
      spawnTimer = baseInterval * 0.9;
      return;
    }

    // Reaction time for THIS wave = base + time to glide to safe lane + small margin
    const WAVE_REACT_S = Math.max(REACTION_TIME_S, bestTime + 0.28);

    // Pick a lane and spawn one object there (obstacle or occasional boost)
    const lane = spawnable[Math.floor(Math.random()*spawnable.length)];
    const yCenter = laneYs[lane];
    const isBoost = Math.random() < BOOST_CHANCE;

    if (isBoost){
      const vxPick = speed * (Math.random()*0.15 + 0.95);
      objs.push({
        kind: 'pick', type: 'boost', lane,
        x: safeSpawnX(vxPick, WAVE_REACT_S),
        y: yCenter - PICK.h/2,
        w: PICK.w, h: PICK.h,
        vx: -vxPick, passed:false
      });
    } else {
      const roll = Math.random();
      const type = roll < 0.33 ? 'barricade' : (roll < 0.66 ? 'cat' : 'cone');
      const vxObst = speed * (Math.random()*0.2 + 0.9);
      objs.push({
        kind:'obst', type, lane,
        x: safeSpawnX(vxObst, WAVE_REACT_S),
        y: yCenter - OBST.h/2,
        w: OBST.w, h: OBST.h,
        vx: -vxObst, passed:false
      });
    }

    // Cooldown for that lane based on pixel gap
    const pxPerSec = Math.max(160, speed);
    laneCooldown[lane] = DESIRED_GAP_PX / pxPerSec;

    // Schedule next attempt
    spawnTimer = baseInterval * (0.9 + Math.random() * 0.25);
  }
  // -------------------------------------------------------------------------

  function rectOverlap(ax,ay,aw,ah, bx,by,bw,bh){
    return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
  }

  // Effects
  let shakeTime=0, flashTime=0;
  function shake(ms){ shakeTime = ms; }
  function flash(ms){ flashTime = ms; }

  function update(dt){
    if (!running || paused || over) return;

    // Timers
    if (invulnMs > 0) invulnMs -= dt*1000;

    // Speed
    speed += SPEED_GAIN*dt; if (speed > MAX_SPEED) speed = MAX_SPEED;

    // Score
    distance += speed * dt * 0.25;
    updateHUD();

    // Spawning
    spawnTick(dt);

    // Move & collisions
    for (let i=objs.length-1;i>=0;i--){
      const o = objs[i];
      o.x += o.vx * dt;

      if (!o.passed && o.x + o.w < TRUCK_X){
        o.passed = true;
        if (o.kind === 'obst'){ streak++; if (streak>maxStreak) maxStreak=streak; }
      }

      // Forgiving hitbox
      const tx = TRUCK_X + HITBOX_PAD, ty = truck.y + HITBOX_PAD;
      const tw = TRUCK.w - HITBOX_PAD*2, th = TRUCK.h - HITBOX_PAD*2;

      if (invulnMs <= 0 && rectOverlap(tx,ty,tw,th, o.x,o.y,o.w,o.h)){
        if (o.kind === 'pick'){
          // Boost: speed & points
          objs.splice(i,1);
          distance += 12;
          speed = Math.min(speed + 50, MAX_SPEED);
          truckGlow = 260;
          floatTexts.push({text:"+Speed!", x: TRUCK_X + TRUCK.w/2, y: truck.y - 6, life: 900});
          continue;
        } else {
          // Obstacle hit
          objs.splice(i,1);
          lives--; streak = 0;
          shake(140); flash(110);
          if (lives <= 0){
            running = false; over = true;
            bestDistance = Math.max(bestDistance, Math.floor(distance));
            overDist.textContent = Math.floor(distance)+' m';
            overBest.textContent = bestDistance+' m';
            overStreak.textContent = maxStreak.toString();
            setTimeout(()=>showOver(), 220);
          }
          updateHUD();
          continue;
        }
      }

      // Cleanup
      if (o.x < -200) objs.splice(i,1);
    }

    // Fast glide lane change
    const targetY = laneYs[truck.targetLane] - TRUCK.h/2;
    const dy = targetY - truck.y;
    truck.y += Math.sign(dy) * Math.min(Math.abs(dy), LANE_CHANGE_SPEED * dt);

    // Floating texts
    for (let i=floatTexts.length-1;i>=0;i--){
      const t = floatTexts[i];
      t.y -= 40 * dt;
      t.life -= dt*1000;
      if (t.life <= 0) floatTexts.splice(i,1);
    }

    // Truck glow timer
    if (truckGlow > 0) truckGlow -= dt*1000;
  }

  function render(){
    const now = performance.now();
    const dt = Math.min(0.05, (now - last)/1000);
    last = now;

    update(dt);

    // Shake offset
    let sx=0, sy=0;
    if (shakeTime>0){
      shakeTime -= dt*1000;
      const p = Math.max(0, shakeTime/1000);
      sx = (Math.random()-.5)*9*p; sy = (Math.random()-.5)*9*p;
    }

    c.save(); c.translate(sx, sy);
    drawBackground();

    // Draw objects
    for (const o of objs) drawObstacle(o);

    // Draw truck IMAGE (with glow if boosted)
    drawTruckImage(TRUCK_X, truck.y, truckGlow > 0);

    // Floating texts
    c.save();
    c.font = "bold 22px Inter, Arial";
    c.textAlign = "center";
    for (const t of floatTexts){
      const alpha = Math.max(0, Math.min(1, t.life / 900));
      c.fillStyle = `rgba(50,205,50,${alpha})`;
      c.fillText(t.text, t.x, t.y);
    }
    c.restore();

    c.restore();

    // Damage flash overlay
    if (flashTime>0){
      flashTime -= dt*1000;
      c.fillStyle = '#5a0f0f';
      c.globalAlpha = Math.max(0, flashTime/180);
      c.fillRect(0,0,W,H);
      c.globalAlpha = 1;
    }

    requestAnimationFrame(render);
  }

  // Input
  function moveLane(delta){
    if (!running || over) return;
    const prev = truck.targetLane ?? 1;
    const next = Math.max(0, Math.min(lanes-1, prev + delta));
    if (next !== prev){
      truck.targetLane = next;
      // start grace window after lane change
      invulnMs = INVULN_MS;
    }
  }

  window.addEventListener('keydown', (e)=>{
    if (e.code==='ArrowUp' || e.code==='KeyW'){ e.preventDefault(); moveLane(-1); }
    if (e.code==='ArrowDown'|| e.code==='KeyS'){ e.preventDefault(); moveLane( 1); }
    if (e.code==='KeyP'){ paused = !paused; }
    if (e.code==='Enter' && over){ hideOver(); resetGame(); }
  });

  // Touch: tap top/bottom halves to change lanes
  canvas.addEventListener('pointerdown', (e)=>{
    const rect = canvas.getBoundingClientRect();
    const y = (e.clientY - rect.top) * (H / rect.height);
    if (y < (roadTop + roadBottom)/2) moveLane(-1); else moveLane(1);
  });

  // Buttons & modals
  restartBtn.addEventListener('click', ()=>{ hideOver(); resetGame(); });
  helpBtn.addEventListener('click', ()=>{ running=false; paused=true; showStart(); });
  startBtn.addEventListener('click', ()=>{ hideStart(); paused=false; running=true; });
  againBtn.addEventListener('click', ()=>{ hideOver(); resetGame(); });

  // Boot
  showStart();
  render();
})();
</script>
</body>
</html>
